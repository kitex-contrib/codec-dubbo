// Code generated by Kitex v0.7.1. DO NOT EDIT.

package echo

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"

	"github.com/apache/thrift/lib/go/thrift"

	"github.com/kitex-contrib/codec-dubbo/pkg/hessian2"
	codec "github.com/kitex-contrib/codec-dubbo/pkg/iface"
	"github.com/pkg/errors"
)

// unused protection
var (
	_ = fmt.Formatter(nil)
	_ = (*bytes.Buffer)(nil)
	_ = (*strings.Builder)(nil)
	_ = reflect.Type(nil)
	_ = thrift.TProtocol(nil)
)

type TestServiceEchoIntArgs struct {
	Req int32 `thrift:"req,1" frugal:"1,default,i32" json:"req"`
}

func NewTestServiceEchoIntArgs() *TestServiceEchoIntArgs {
	return &TestServiceEchoIntArgs{}
}

func (p *TestServiceEchoIntArgs) InitDefault() {
	*p = TestServiceEchoIntArgs{}
}

func (p *TestServiceEchoIntArgs) GetReq() (v int32) {
	return p.Req
}
func (p *TestServiceEchoIntArgs) SetReq(val int32) {
	p.Req = val
}

func (p *TestServiceEchoIntArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoIntArgs(%+v)", *p)
}
func (p *TestServiceEchoIntArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoIntArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoIntArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoIntResult struct {
	Success *int32 `thrift:"success,0,optional" frugal:"0,optional,i32" json:"success,omitempty"`
}

func NewTestServiceEchoIntResult() *TestServiceEchoIntResult {
	return &TestServiceEchoIntResult{}
}

func (p *TestServiceEchoIntResult) InitDefault() {
	*p = TestServiceEchoIntResult{}
}

var TestServiceEchoIntResult_Success_DEFAULT int32

func (p *TestServiceEchoIntResult) GetSuccess() (v int32) {
	if !p.IsSetSuccess() {
		return TestServiceEchoIntResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoIntResult) SetSuccess(x interface{}) {
	p.Success = x.(*int32)
}

func (p *TestServiceEchoIntResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoIntResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoIntResult(%+v)", *p)
}
func (p *TestServiceEchoIntResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoIntResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoIntResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBoolArgs struct {
	Req bool `thrift:"req,1" frugal:"1,default,bool" json:"req"`
}

func NewTestServiceEchoBoolArgs() *TestServiceEchoBoolArgs {
	return &TestServiceEchoBoolArgs{}
}

func (p *TestServiceEchoBoolArgs) InitDefault() {
	*p = TestServiceEchoBoolArgs{}
}

func (p *TestServiceEchoBoolArgs) GetReq() (v bool) {
	return p.Req
}
func (p *TestServiceEchoBoolArgs) SetReq(val bool) {
	p.Req = val
}

func (p *TestServiceEchoBoolArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBoolArgs(%+v)", *p)
}
func (p *TestServiceEchoBoolArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBoolArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBoolArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBoolResult struct {
	Success *bool `thrift:"success,0,optional" frugal:"0,optional,bool" json:"success,omitempty"`
}

func NewTestServiceEchoBoolResult() *TestServiceEchoBoolResult {
	return &TestServiceEchoBoolResult{}
}

func (p *TestServiceEchoBoolResult) InitDefault() {
	*p = TestServiceEchoBoolResult{}
}

var TestServiceEchoBoolResult_Success_DEFAULT bool

func (p *TestServiceEchoBoolResult) GetSuccess() (v bool) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBoolResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoBoolResult) SetSuccess(x interface{}) {
	p.Success = x.(*bool)
}

func (p *TestServiceEchoBoolResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBoolResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBoolResult(%+v)", *p)
}
func (p *TestServiceEchoBoolResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBoolResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBoolResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoByteArgs struct {
	Req int8 `thrift:"req,1" frugal:"1,default,byte" json:"req"`
}

func NewTestServiceEchoByteArgs() *TestServiceEchoByteArgs {
	return &TestServiceEchoByteArgs{}
}

func (p *TestServiceEchoByteArgs) InitDefault() {
	*p = TestServiceEchoByteArgs{}
}

func (p *TestServiceEchoByteArgs) GetReq() (v int8) {
	return p.Req
}
func (p *TestServiceEchoByteArgs) SetReq(val int8) {
	p.Req = val
}

func (p *TestServiceEchoByteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoByteArgs(%+v)", *p)
}
func (p *TestServiceEchoByteArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoByteArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoByteArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoByteResult struct {
	Success *int8 `thrift:"success,0,optional" frugal:"0,optional,byte" json:"success,omitempty"`
}

func NewTestServiceEchoByteResult() *TestServiceEchoByteResult {
	return &TestServiceEchoByteResult{}
}

func (p *TestServiceEchoByteResult) InitDefault() {
	*p = TestServiceEchoByteResult{}
}

var TestServiceEchoByteResult_Success_DEFAULT int8

func (p *TestServiceEchoByteResult) GetSuccess() (v int8) {
	if !p.IsSetSuccess() {
		return TestServiceEchoByteResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoByteResult) SetSuccess(x interface{}) {
	p.Success = x.(*int8)
}

func (p *TestServiceEchoByteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoByteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoByteResult(%+v)", *p)
}
func (p *TestServiceEchoByteResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoByteResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoByteResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt16Args struct {
	Req int16 `thrift:"req,1" frugal:"1,default,i16" json:"req"`
}

func NewTestServiceEchoInt16Args() *TestServiceEchoInt16Args {
	return &TestServiceEchoInt16Args{}
}

func (p *TestServiceEchoInt16Args) InitDefault() {
	*p = TestServiceEchoInt16Args{}
}

func (p *TestServiceEchoInt16Args) GetReq() (v int16) {
	return p.Req
}
func (p *TestServiceEchoInt16Args) SetReq(val int16) {
	p.Req = val
}

func (p *TestServiceEchoInt16Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt16Args(%+v)", *p)
}
func (p *TestServiceEchoInt16Args) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoInt16Args) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt16Args) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt16Result struct {
	Success *int16 `thrift:"success,0,optional" frugal:"0,optional,i16" json:"success,omitempty"`
}

func NewTestServiceEchoInt16Result() *TestServiceEchoInt16Result {
	return &TestServiceEchoInt16Result{}
}

func (p *TestServiceEchoInt16Result) InitDefault() {
	*p = TestServiceEchoInt16Result{}
}

var TestServiceEchoInt16Result_Success_DEFAULT int16

func (p *TestServiceEchoInt16Result) GetSuccess() (v int16) {
	if !p.IsSetSuccess() {
		return TestServiceEchoInt16Result_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoInt16Result) SetSuccess(x interface{}) {
	p.Success = x.(*int16)
}

func (p *TestServiceEchoInt16Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoInt16Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt16Result(%+v)", *p)
}
func (p *TestServiceEchoInt16Result) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoInt16Result) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt16Result) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt32Args struct {
	Req int32 `thrift:"req,1" frugal:"1,default,i32" json:"req"`
}

func NewTestServiceEchoInt32Args() *TestServiceEchoInt32Args {
	return &TestServiceEchoInt32Args{}
}

func (p *TestServiceEchoInt32Args) InitDefault() {
	*p = TestServiceEchoInt32Args{}
}

func (p *TestServiceEchoInt32Args) GetReq() (v int32) {
	return p.Req
}
func (p *TestServiceEchoInt32Args) SetReq(val int32) {
	p.Req = val
}

func (p *TestServiceEchoInt32Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt32Args(%+v)", *p)
}
func (p *TestServiceEchoInt32Args) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoInt32Args) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt32Args) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt32Result struct {
	Success *int32 `thrift:"success,0,optional" frugal:"0,optional,i32" json:"success,omitempty"`
}

func NewTestServiceEchoInt32Result() *TestServiceEchoInt32Result {
	return &TestServiceEchoInt32Result{}
}

func (p *TestServiceEchoInt32Result) InitDefault() {
	*p = TestServiceEchoInt32Result{}
}

var TestServiceEchoInt32Result_Success_DEFAULT int32

func (p *TestServiceEchoInt32Result) GetSuccess() (v int32) {
	if !p.IsSetSuccess() {
		return TestServiceEchoInt32Result_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoInt32Result) SetSuccess(x interface{}) {
	p.Success = x.(*int32)
}

func (p *TestServiceEchoInt32Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoInt32Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt32Result(%+v)", *p)
}
func (p *TestServiceEchoInt32Result) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoInt32Result) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt32Result) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt64Args struct {
	Req int64 `thrift:"req,1" frugal:"1,default,i64" json:"req"`
}

func NewTestServiceEchoInt64Args() *TestServiceEchoInt64Args {
	return &TestServiceEchoInt64Args{}
}

func (p *TestServiceEchoInt64Args) InitDefault() {
	*p = TestServiceEchoInt64Args{}
}

func (p *TestServiceEchoInt64Args) GetReq() (v int64) {
	return p.Req
}
func (p *TestServiceEchoInt64Args) SetReq(val int64) {
	p.Req = val
}

func (p *TestServiceEchoInt64Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt64Args(%+v)", *p)
}
func (p *TestServiceEchoInt64Args) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoInt64Args) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt64Args) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt64Result struct {
	Success *int64 `thrift:"success,0,optional" frugal:"0,optional,i64" json:"success,omitempty"`
}

func NewTestServiceEchoInt64Result() *TestServiceEchoInt64Result {
	return &TestServiceEchoInt64Result{}
}

func (p *TestServiceEchoInt64Result) InitDefault() {
	*p = TestServiceEchoInt64Result{}
}

var TestServiceEchoInt64Result_Success_DEFAULT int64

func (p *TestServiceEchoInt64Result) GetSuccess() (v int64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoInt64Result_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoInt64Result) SetSuccess(x interface{}) {
	p.Success = x.(*int64)
}

func (p *TestServiceEchoInt64Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoInt64Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt64Result(%+v)", *p)
}
func (p *TestServiceEchoInt64Result) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoInt64Result) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt64Result) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoDoubleArgs struct {
	Req float64 `thrift:"req,1" frugal:"1,default,double" json:"req"`
}

func NewTestServiceEchoDoubleArgs() *TestServiceEchoDoubleArgs {
	return &TestServiceEchoDoubleArgs{}
}

func (p *TestServiceEchoDoubleArgs) InitDefault() {
	*p = TestServiceEchoDoubleArgs{}
}

func (p *TestServiceEchoDoubleArgs) GetReq() (v float64) {
	return p.Req
}
func (p *TestServiceEchoDoubleArgs) SetReq(val float64) {
	p.Req = val
}

func (p *TestServiceEchoDoubleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoDoubleArgs(%+v)", *p)
}
func (p *TestServiceEchoDoubleArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoDoubleArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoDoubleArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoDoubleResult struct {
	Success *float64 `thrift:"success,0,optional" frugal:"0,optional,double" json:"success,omitempty"`
}

func NewTestServiceEchoDoubleResult() *TestServiceEchoDoubleResult {
	return &TestServiceEchoDoubleResult{}
}

func (p *TestServiceEchoDoubleResult) InitDefault() {
	*p = TestServiceEchoDoubleResult{}
}

var TestServiceEchoDoubleResult_Success_DEFAULT float64

func (p *TestServiceEchoDoubleResult) GetSuccess() (v float64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoDoubleResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoDoubleResult) SetSuccess(x interface{}) {
	p.Success = x.(*float64)
}

func (p *TestServiceEchoDoubleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoDoubleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoDoubleResult(%+v)", *p)
}
func (p *TestServiceEchoDoubleResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoDoubleResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoDoubleResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoStringArgs struct {
	Req string `thrift:"req,1" frugal:"1,default,string" json:"req"`
}

func NewTestServiceEchoStringArgs() *TestServiceEchoStringArgs {
	return &TestServiceEchoStringArgs{}
}

func (p *TestServiceEchoStringArgs) InitDefault() {
	*p = TestServiceEchoStringArgs{}
}

func (p *TestServiceEchoStringArgs) GetReq() (v string) {
	return p.Req
}
func (p *TestServiceEchoStringArgs) SetReq(val string) {
	p.Req = val
}

func (p *TestServiceEchoStringArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoStringArgs(%+v)", *p)
}
func (p *TestServiceEchoStringArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoStringArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoStringArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoStringResult struct {
	Success *string `thrift:"success,0,optional" frugal:"0,optional,string" json:"success,omitempty"`
}

func NewTestServiceEchoStringResult() *TestServiceEchoStringResult {
	return &TestServiceEchoStringResult{}
}

func (p *TestServiceEchoStringResult) InitDefault() {
	*p = TestServiceEchoStringResult{}
}

var TestServiceEchoStringResult_Success_DEFAULT string

func (p *TestServiceEchoStringResult) GetSuccess() (v string) {
	if !p.IsSetSuccess() {
		return TestServiceEchoStringResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestServiceEchoStringResult) SetSuccess(x interface{}) {
	p.Success = x.(*string)
}

func (p *TestServiceEchoStringResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoStringResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoStringResult(%+v)", *p)
}
func (p *TestServiceEchoStringResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoStringResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoStringResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBinaryArgs struct {
	Req []byte `thrift:"req,1" frugal:"1,default,binary" json:"req"`
}

func NewTestServiceEchoBinaryArgs() *TestServiceEchoBinaryArgs {
	return &TestServiceEchoBinaryArgs{}
}

func (p *TestServiceEchoBinaryArgs) InitDefault() {
	*p = TestServiceEchoBinaryArgs{}
}

func (p *TestServiceEchoBinaryArgs) GetReq() (v []byte) {
	return p.Req
}
func (p *TestServiceEchoBinaryArgs) SetReq(val []byte) {
	p.Req = val
}

func (p *TestServiceEchoBinaryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBinaryArgs(%+v)", *p)
}
func (p *TestServiceEchoBinaryArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBinaryArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBinaryArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBinaryResult struct {
	Success []byte `thrift:"success,0,optional" frugal:"0,optional,binary" json:"success,omitempty"`
}

func NewTestServiceEchoBinaryResult() *TestServiceEchoBinaryResult {
	return &TestServiceEchoBinaryResult{}
}

func (p *TestServiceEchoBinaryResult) InitDefault() {
	*p = TestServiceEchoBinaryResult{}
}

var TestServiceEchoBinaryResult_Success_DEFAULT []byte

func (p *TestServiceEchoBinaryResult) GetSuccess() (v []byte) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBinaryResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBinaryResult) SetSuccess(x interface{}) {
	p.Success = x.([]byte)
}

func (p *TestServiceEchoBinaryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBinaryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBinaryResult(%+v)", *p)
}
func (p *TestServiceEchoBinaryResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBinaryResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBinaryResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoArgs struct {
	Req *EchoRequest `thrift:"req,1" frugal:"1,default,EchoRequest" json:"req"`
}

func NewTestServiceEchoArgs() *TestServiceEchoArgs {
	return &TestServiceEchoArgs{}
}

func (p *TestServiceEchoArgs) InitDefault() {
	*p = TestServiceEchoArgs{}
}

var TestServiceEchoArgs_Req_DEFAULT *EchoRequest

func (p *TestServiceEchoArgs) GetReq() (v *EchoRequest) {
	if !p.IsSetReq() {
		return TestServiceEchoArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *TestServiceEchoArgs) SetReq(val *EchoRequest) {
	p.Req = val
}

func (p *TestServiceEchoArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *TestServiceEchoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoArgs(%+v)", *p)
}
func (p *TestServiceEchoArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoResult struct {
	Success *EchoResponse `thrift:"success,0,optional" frugal:"0,optional,EchoResponse" json:"success,omitempty"`
}

func NewTestServiceEchoResult() *TestServiceEchoResult {
	return &TestServiceEchoResult{}
}

func (p *TestServiceEchoResult) InitDefault() {
	*p = TestServiceEchoResult{}
}

var TestServiceEchoResult_Success_DEFAULT *EchoResponse

func (p *TestServiceEchoResult) GetSuccess() (v *EchoResponse) {
	if !p.IsSetSuccess() {
		return TestServiceEchoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoResult) SetSuccess(x interface{}) {
	p.Success = x.(*EchoResponse)
}

func (p *TestServiceEchoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoResult(%+v)", *p)
}
func (p *TestServiceEchoResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBoolListArgs struct {
	Req []bool `thrift:"req,1" frugal:"1,default,list<bool>" json:"req"`
}

func NewTestServiceEchoBoolListArgs() *TestServiceEchoBoolListArgs {
	return &TestServiceEchoBoolListArgs{}
}

func (p *TestServiceEchoBoolListArgs) InitDefault() {
	*p = TestServiceEchoBoolListArgs{}
}

func (p *TestServiceEchoBoolListArgs) GetReq() (v []bool) {
	return p.Req
}
func (p *TestServiceEchoBoolListArgs) SetReq(val []bool) {
	p.Req = val
}

func (p *TestServiceEchoBoolListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBoolListArgs(%+v)", *p)
}
func (p *TestServiceEchoBoolListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBoolListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBoolListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBoolListResult struct {
	Success []bool `thrift:"success,0,optional" frugal:"0,optional,list<bool>" json:"success,omitempty"`
}

func NewTestServiceEchoBoolListResult() *TestServiceEchoBoolListResult {
	return &TestServiceEchoBoolListResult{}
}

func (p *TestServiceEchoBoolListResult) InitDefault() {
	*p = TestServiceEchoBoolListResult{}
}

var TestServiceEchoBoolListResult_Success_DEFAULT []bool

func (p *TestServiceEchoBoolListResult) GetSuccess() (v []bool) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBoolListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBoolListResult) SetSuccess(x interface{}) {
	p.Success = x.([]bool)
}

func (p *TestServiceEchoBoolListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBoolListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBoolListResult(%+v)", *p)
}
func (p *TestServiceEchoBoolListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBoolListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBoolListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoByteListArgs struct {
	Req []int8 `thrift:"req,1" frugal:"1,default,list<byte>" json:"req"`
}

func NewTestServiceEchoByteListArgs() *TestServiceEchoByteListArgs {
	return &TestServiceEchoByteListArgs{}
}

func (p *TestServiceEchoByteListArgs) InitDefault() {
	*p = TestServiceEchoByteListArgs{}
}

func (p *TestServiceEchoByteListArgs) GetReq() (v []int8) {
	return p.Req
}
func (p *TestServiceEchoByteListArgs) SetReq(val []int8) {
	p.Req = val
}

func (p *TestServiceEchoByteListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoByteListArgs(%+v)", *p)
}
func (p *TestServiceEchoByteListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoByteListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoByteListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoByteListResult struct {
	Success []int8 `thrift:"success,0,optional" frugal:"0,optional,list<byte>" json:"success,omitempty"`
}

func NewTestServiceEchoByteListResult() *TestServiceEchoByteListResult {
	return &TestServiceEchoByteListResult{}
}

func (p *TestServiceEchoByteListResult) InitDefault() {
	*p = TestServiceEchoByteListResult{}
}

var TestServiceEchoByteListResult_Success_DEFAULT []int8

func (p *TestServiceEchoByteListResult) GetSuccess() (v []int8) {
	if !p.IsSetSuccess() {
		return TestServiceEchoByteListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoByteListResult) SetSuccess(x interface{}) {
	p.Success = x.([]int8)
}

func (p *TestServiceEchoByteListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoByteListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoByteListResult(%+v)", *p)
}
func (p *TestServiceEchoByteListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoByteListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoByteListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt16ListArgs struct {
	Req []int16 `thrift:"req,1" frugal:"1,default,list<i16>" json:"req"`
}

func NewTestServiceEchoInt16ListArgs() *TestServiceEchoInt16ListArgs {
	return &TestServiceEchoInt16ListArgs{}
}

func (p *TestServiceEchoInt16ListArgs) InitDefault() {
	*p = TestServiceEchoInt16ListArgs{}
}

func (p *TestServiceEchoInt16ListArgs) GetReq() (v []int16) {
	return p.Req
}
func (p *TestServiceEchoInt16ListArgs) SetReq(val []int16) {
	p.Req = val
}

func (p *TestServiceEchoInt16ListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt16ListArgs(%+v)", *p)
}
func (p *TestServiceEchoInt16ListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoInt16ListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt16ListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt16ListResult struct {
	Success []int16 `thrift:"success,0,optional" frugal:"0,optional,list<i16>" json:"success,omitempty"`
}

func NewTestServiceEchoInt16ListResult() *TestServiceEchoInt16ListResult {
	return &TestServiceEchoInt16ListResult{}
}

func (p *TestServiceEchoInt16ListResult) InitDefault() {
	*p = TestServiceEchoInt16ListResult{}
}

var TestServiceEchoInt16ListResult_Success_DEFAULT []int16

func (p *TestServiceEchoInt16ListResult) GetSuccess() (v []int16) {
	if !p.IsSetSuccess() {
		return TestServiceEchoInt16ListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoInt16ListResult) SetSuccess(x interface{}) {
	p.Success = x.([]int16)
}

func (p *TestServiceEchoInt16ListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoInt16ListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt16ListResult(%+v)", *p)
}
func (p *TestServiceEchoInt16ListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoInt16ListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt16ListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt32ListArgs struct {
	Req []int32 `thrift:"req,1" frugal:"1,default,list<i32>" json:"req"`
}

func NewTestServiceEchoInt32ListArgs() *TestServiceEchoInt32ListArgs {
	return &TestServiceEchoInt32ListArgs{}
}

func (p *TestServiceEchoInt32ListArgs) InitDefault() {
	*p = TestServiceEchoInt32ListArgs{}
}

func (p *TestServiceEchoInt32ListArgs) GetReq() (v []int32) {
	return p.Req
}
func (p *TestServiceEchoInt32ListArgs) SetReq(val []int32) {
	p.Req = val
}

func (p *TestServiceEchoInt32ListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt32ListArgs(%+v)", *p)
}
func (p *TestServiceEchoInt32ListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoInt32ListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt32ListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt32ListResult struct {
	Success []int32 `thrift:"success,0,optional" frugal:"0,optional,list<i32>" json:"success,omitempty"`
}

func NewTestServiceEchoInt32ListResult() *TestServiceEchoInt32ListResult {
	return &TestServiceEchoInt32ListResult{}
}

func (p *TestServiceEchoInt32ListResult) InitDefault() {
	*p = TestServiceEchoInt32ListResult{}
}

var TestServiceEchoInt32ListResult_Success_DEFAULT []int32

func (p *TestServiceEchoInt32ListResult) GetSuccess() (v []int32) {
	if !p.IsSetSuccess() {
		return TestServiceEchoInt32ListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoInt32ListResult) SetSuccess(x interface{}) {
	p.Success = x.([]int32)
}

func (p *TestServiceEchoInt32ListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoInt32ListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt32ListResult(%+v)", *p)
}
func (p *TestServiceEchoInt32ListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoInt32ListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt32ListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt64ListArgs struct {
	Req []int64 `thrift:"req,1" frugal:"1,default,list<i64>" json:"req"`
}

func NewTestServiceEchoInt64ListArgs() *TestServiceEchoInt64ListArgs {
	return &TestServiceEchoInt64ListArgs{}
}

func (p *TestServiceEchoInt64ListArgs) InitDefault() {
	*p = TestServiceEchoInt64ListArgs{}
}

func (p *TestServiceEchoInt64ListArgs) GetReq() (v []int64) {
	return p.Req
}
func (p *TestServiceEchoInt64ListArgs) SetReq(val []int64) {
	p.Req = val
}

func (p *TestServiceEchoInt64ListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt64ListArgs(%+v)", *p)
}
func (p *TestServiceEchoInt64ListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoInt64ListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt64ListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoInt64ListResult struct {
	Success []int64 `thrift:"success,0,optional" frugal:"0,optional,list<i64>" json:"success,omitempty"`
}

func NewTestServiceEchoInt64ListResult() *TestServiceEchoInt64ListResult {
	return &TestServiceEchoInt64ListResult{}
}

func (p *TestServiceEchoInt64ListResult) InitDefault() {
	*p = TestServiceEchoInt64ListResult{}
}

var TestServiceEchoInt64ListResult_Success_DEFAULT []int64

func (p *TestServiceEchoInt64ListResult) GetSuccess() (v []int64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoInt64ListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoInt64ListResult) SetSuccess(x interface{}) {
	p.Success = x.([]int64)
}

func (p *TestServiceEchoInt64ListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoInt64ListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoInt64ListResult(%+v)", *p)
}
func (p *TestServiceEchoInt64ListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoInt64ListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoInt64ListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoDoubleListArgs struct {
	Req []float64 `thrift:"req,1" frugal:"1,default,list<double>" json:"req"`
}

func NewTestServiceEchoDoubleListArgs() *TestServiceEchoDoubleListArgs {
	return &TestServiceEchoDoubleListArgs{}
}

func (p *TestServiceEchoDoubleListArgs) InitDefault() {
	*p = TestServiceEchoDoubleListArgs{}
}

func (p *TestServiceEchoDoubleListArgs) GetReq() (v []float64) {
	return p.Req
}
func (p *TestServiceEchoDoubleListArgs) SetReq(val []float64) {
	p.Req = val
}

func (p *TestServiceEchoDoubleListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoDoubleListArgs(%+v)", *p)
}
func (p *TestServiceEchoDoubleListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoDoubleListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoDoubleListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoDoubleListResult struct {
	Success []float64 `thrift:"success,0,optional" frugal:"0,optional,list<double>" json:"success,omitempty"`
}

func NewTestServiceEchoDoubleListResult() *TestServiceEchoDoubleListResult {
	return &TestServiceEchoDoubleListResult{}
}

func (p *TestServiceEchoDoubleListResult) InitDefault() {
	*p = TestServiceEchoDoubleListResult{}
}

var TestServiceEchoDoubleListResult_Success_DEFAULT []float64

func (p *TestServiceEchoDoubleListResult) GetSuccess() (v []float64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoDoubleListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoDoubleListResult) SetSuccess(x interface{}) {
	p.Success = x.([]float64)
}

func (p *TestServiceEchoDoubleListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoDoubleListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoDoubleListResult(%+v)", *p)
}
func (p *TestServiceEchoDoubleListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoDoubleListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoDoubleListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoStringListArgs struct {
	Req []string `thrift:"req,1" frugal:"1,default,list<string>" json:"req"`
}

func NewTestServiceEchoStringListArgs() *TestServiceEchoStringListArgs {
	return &TestServiceEchoStringListArgs{}
}

func (p *TestServiceEchoStringListArgs) InitDefault() {
	*p = TestServiceEchoStringListArgs{}
}

func (p *TestServiceEchoStringListArgs) GetReq() (v []string) {
	return p.Req
}
func (p *TestServiceEchoStringListArgs) SetReq(val []string) {
	p.Req = val
}

func (p *TestServiceEchoStringListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoStringListArgs(%+v)", *p)
}
func (p *TestServiceEchoStringListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoStringListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoStringListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoStringListResult struct {
	Success []string `thrift:"success,0,optional" frugal:"0,optional,list<string>" json:"success,omitempty"`
}

func NewTestServiceEchoStringListResult() *TestServiceEchoStringListResult {
	return &TestServiceEchoStringListResult{}
}

func (p *TestServiceEchoStringListResult) InitDefault() {
	*p = TestServiceEchoStringListResult{}
}

var TestServiceEchoStringListResult_Success_DEFAULT []string

func (p *TestServiceEchoStringListResult) GetSuccess() (v []string) {
	if !p.IsSetSuccess() {
		return TestServiceEchoStringListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoStringListResult) SetSuccess(x interface{}) {
	p.Success = x.([]string)
}

func (p *TestServiceEchoStringListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoStringListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoStringListResult(%+v)", *p)
}
func (p *TestServiceEchoStringListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoStringListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoStringListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBinaryListArgs struct {
	Req [][]byte `thrift:"req,1" frugal:"1,default,list<binary>" json:"req"`
}

func NewTestServiceEchoBinaryListArgs() *TestServiceEchoBinaryListArgs {
	return &TestServiceEchoBinaryListArgs{}
}

func (p *TestServiceEchoBinaryListArgs) InitDefault() {
	*p = TestServiceEchoBinaryListArgs{}
}

func (p *TestServiceEchoBinaryListArgs) GetReq() (v [][]byte) {
	return p.Req
}
func (p *TestServiceEchoBinaryListArgs) SetReq(val [][]byte) {
	p.Req = val
}

func (p *TestServiceEchoBinaryListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBinaryListArgs(%+v)", *p)
}
func (p *TestServiceEchoBinaryListArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBinaryListArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBinaryListArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBinaryListResult struct {
	Success [][]byte `thrift:"success,0,optional" frugal:"0,optional,list<binary>" json:"success,omitempty"`
}

func NewTestServiceEchoBinaryListResult() *TestServiceEchoBinaryListResult {
	return &TestServiceEchoBinaryListResult{}
}

func (p *TestServiceEchoBinaryListResult) InitDefault() {
	*p = TestServiceEchoBinaryListResult{}
}

var TestServiceEchoBinaryListResult_Success_DEFAULT [][]byte

func (p *TestServiceEchoBinaryListResult) GetSuccess() (v [][]byte) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBinaryListResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBinaryListResult) SetSuccess(x interface{}) {
	p.Success = x.([][]byte)
}

func (p *TestServiceEchoBinaryListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBinaryListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBinaryListResult(%+v)", *p)
}
func (p *TestServiceEchoBinaryListResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBinaryListResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBinaryListResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BoolMapArgs struct {
	Req map[bool]bool `thrift:"req,1" frugal:"1,default,map<bool:bool>" json:"req"`
}

func NewTestServiceEchoBool2BoolMapArgs() *TestServiceEchoBool2BoolMapArgs {
	return &TestServiceEchoBool2BoolMapArgs{}
}

func (p *TestServiceEchoBool2BoolMapArgs) InitDefault() {
	*p = TestServiceEchoBool2BoolMapArgs{}
}

func (p *TestServiceEchoBool2BoolMapArgs) GetReq() (v map[bool]bool) {
	return p.Req
}
func (p *TestServiceEchoBool2BoolMapArgs) SetReq(val map[bool]bool) {
	p.Req = val
}

func (p *TestServiceEchoBool2BoolMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BoolMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2BoolMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2BoolMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BoolMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BoolMapResult struct {
	Success map[bool]bool `thrift:"success,0,optional" frugal:"0,optional,map<bool:bool>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2BoolMapResult() *TestServiceEchoBool2BoolMapResult {
	return &TestServiceEchoBool2BoolMapResult{}
}

func (p *TestServiceEchoBool2BoolMapResult) InitDefault() {
	*p = TestServiceEchoBool2BoolMapResult{}
}

var TestServiceEchoBool2BoolMapResult_Success_DEFAULT map[bool]bool

func (p *TestServiceEchoBool2BoolMapResult) GetSuccess() (v map[bool]bool) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2BoolMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2BoolMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]bool)
}

func (p *TestServiceEchoBool2BoolMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2BoolMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BoolMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2BoolMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2BoolMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BoolMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2ByteMapArgs struct {
	Req map[bool]int8 `thrift:"req,1" frugal:"1,default,map<bool:byte>" json:"req"`
}

func NewTestServiceEchoBool2ByteMapArgs() *TestServiceEchoBool2ByteMapArgs {
	return &TestServiceEchoBool2ByteMapArgs{}
}

func (p *TestServiceEchoBool2ByteMapArgs) InitDefault() {
	*p = TestServiceEchoBool2ByteMapArgs{}
}

func (p *TestServiceEchoBool2ByteMapArgs) GetReq() (v map[bool]int8) {
	return p.Req
}
func (p *TestServiceEchoBool2ByteMapArgs) SetReq(val map[bool]int8) {
	p.Req = val
}

func (p *TestServiceEchoBool2ByteMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2ByteMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2ByteMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2ByteMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2ByteMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2ByteMapResult struct {
	Success map[bool]int8 `thrift:"success,0,optional" frugal:"0,optional,map<bool:byte>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2ByteMapResult() *TestServiceEchoBool2ByteMapResult {
	return &TestServiceEchoBool2ByteMapResult{}
}

func (p *TestServiceEchoBool2ByteMapResult) InitDefault() {
	*p = TestServiceEchoBool2ByteMapResult{}
}

var TestServiceEchoBool2ByteMapResult_Success_DEFAULT map[bool]int8

func (p *TestServiceEchoBool2ByteMapResult) GetSuccess() (v map[bool]int8) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2ByteMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2ByteMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]int8)
}

func (p *TestServiceEchoBool2ByteMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2ByteMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2ByteMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2ByteMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2ByteMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2ByteMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int16MapArgs struct {
	Req map[bool]int16 `thrift:"req,1" frugal:"1,default,map<bool:i16>" json:"req"`
}

func NewTestServiceEchoBool2Int16MapArgs() *TestServiceEchoBool2Int16MapArgs {
	return &TestServiceEchoBool2Int16MapArgs{}
}

func (p *TestServiceEchoBool2Int16MapArgs) InitDefault() {
	*p = TestServiceEchoBool2Int16MapArgs{}
}

func (p *TestServiceEchoBool2Int16MapArgs) GetReq() (v map[bool]int16) {
	return p.Req
}
func (p *TestServiceEchoBool2Int16MapArgs) SetReq(val map[bool]int16) {
	p.Req = val
}

func (p *TestServiceEchoBool2Int16MapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int16MapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2Int16MapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2Int16MapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int16MapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int16MapResult struct {
	Success map[bool]int16 `thrift:"success,0,optional" frugal:"0,optional,map<bool:i16>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2Int16MapResult() *TestServiceEchoBool2Int16MapResult {
	return &TestServiceEchoBool2Int16MapResult{}
}

func (p *TestServiceEchoBool2Int16MapResult) InitDefault() {
	*p = TestServiceEchoBool2Int16MapResult{}
}

var TestServiceEchoBool2Int16MapResult_Success_DEFAULT map[bool]int16

func (p *TestServiceEchoBool2Int16MapResult) GetSuccess() (v map[bool]int16) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2Int16MapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2Int16MapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]int16)
}

func (p *TestServiceEchoBool2Int16MapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2Int16MapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int16MapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2Int16MapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2Int16MapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int16MapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int32MapArgs struct {
	Req map[bool]int32 `thrift:"req,1" frugal:"1,default,map<bool:i32>" json:"req"`
}

func NewTestServiceEchoBool2Int32MapArgs() *TestServiceEchoBool2Int32MapArgs {
	return &TestServiceEchoBool2Int32MapArgs{}
}

func (p *TestServiceEchoBool2Int32MapArgs) InitDefault() {
	*p = TestServiceEchoBool2Int32MapArgs{}
}

func (p *TestServiceEchoBool2Int32MapArgs) GetReq() (v map[bool]int32) {
	return p.Req
}
func (p *TestServiceEchoBool2Int32MapArgs) SetReq(val map[bool]int32) {
	p.Req = val
}

func (p *TestServiceEchoBool2Int32MapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int32MapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2Int32MapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2Int32MapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int32MapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int32MapResult struct {
	Success map[bool]int32 `thrift:"success,0,optional" frugal:"0,optional,map<bool:i32>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2Int32MapResult() *TestServiceEchoBool2Int32MapResult {
	return &TestServiceEchoBool2Int32MapResult{}
}

func (p *TestServiceEchoBool2Int32MapResult) InitDefault() {
	*p = TestServiceEchoBool2Int32MapResult{}
}

var TestServiceEchoBool2Int32MapResult_Success_DEFAULT map[bool]int32

func (p *TestServiceEchoBool2Int32MapResult) GetSuccess() (v map[bool]int32) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2Int32MapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2Int32MapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]int32)
}

func (p *TestServiceEchoBool2Int32MapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2Int32MapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int32MapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2Int32MapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2Int32MapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int32MapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int64MapArgs struct {
	Req map[bool]int64 `thrift:"req,1" frugal:"1,default,map<bool:i64>" json:"req"`
}

func NewTestServiceEchoBool2Int64MapArgs() *TestServiceEchoBool2Int64MapArgs {
	return &TestServiceEchoBool2Int64MapArgs{}
}

func (p *TestServiceEchoBool2Int64MapArgs) InitDefault() {
	*p = TestServiceEchoBool2Int64MapArgs{}
}

func (p *TestServiceEchoBool2Int64MapArgs) GetReq() (v map[bool]int64) {
	return p.Req
}
func (p *TestServiceEchoBool2Int64MapArgs) SetReq(val map[bool]int64) {
	p.Req = val
}

func (p *TestServiceEchoBool2Int64MapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int64MapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2Int64MapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2Int64MapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int64MapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int64MapResult struct {
	Success map[bool]int64 `thrift:"success,0,optional" frugal:"0,optional,map<bool:i64>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2Int64MapResult() *TestServiceEchoBool2Int64MapResult {
	return &TestServiceEchoBool2Int64MapResult{}
}

func (p *TestServiceEchoBool2Int64MapResult) InitDefault() {
	*p = TestServiceEchoBool2Int64MapResult{}
}

var TestServiceEchoBool2Int64MapResult_Success_DEFAULT map[bool]int64

func (p *TestServiceEchoBool2Int64MapResult) GetSuccess() (v map[bool]int64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2Int64MapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2Int64MapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]int64)
}

func (p *TestServiceEchoBool2Int64MapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2Int64MapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int64MapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2Int64MapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2Int64MapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int64MapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2DoubleMapArgs struct {
	Req map[bool]float64 `thrift:"req,1" frugal:"1,default,map<bool:double>" json:"req"`
}

func NewTestServiceEchoBool2DoubleMapArgs() *TestServiceEchoBool2DoubleMapArgs {
	return &TestServiceEchoBool2DoubleMapArgs{}
}

func (p *TestServiceEchoBool2DoubleMapArgs) InitDefault() {
	*p = TestServiceEchoBool2DoubleMapArgs{}
}

func (p *TestServiceEchoBool2DoubleMapArgs) GetReq() (v map[bool]float64) {
	return p.Req
}
func (p *TestServiceEchoBool2DoubleMapArgs) SetReq(val map[bool]float64) {
	p.Req = val
}

func (p *TestServiceEchoBool2DoubleMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2DoubleMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2DoubleMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2DoubleMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2DoubleMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2DoubleMapResult struct {
	Success map[bool]float64 `thrift:"success,0,optional" frugal:"0,optional,map<bool:double>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2DoubleMapResult() *TestServiceEchoBool2DoubleMapResult {
	return &TestServiceEchoBool2DoubleMapResult{}
}

func (p *TestServiceEchoBool2DoubleMapResult) InitDefault() {
	*p = TestServiceEchoBool2DoubleMapResult{}
}

var TestServiceEchoBool2DoubleMapResult_Success_DEFAULT map[bool]float64

func (p *TestServiceEchoBool2DoubleMapResult) GetSuccess() (v map[bool]float64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2DoubleMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2DoubleMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]float64)
}

func (p *TestServiceEchoBool2DoubleMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2DoubleMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2DoubleMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2DoubleMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2DoubleMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2DoubleMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2StringMapArgs struct {
	Req map[bool]string `thrift:"req,1" frugal:"1,default,map<bool:string>" json:"req"`
}

func NewTestServiceEchoBool2StringMapArgs() *TestServiceEchoBool2StringMapArgs {
	return &TestServiceEchoBool2StringMapArgs{}
}

func (p *TestServiceEchoBool2StringMapArgs) InitDefault() {
	*p = TestServiceEchoBool2StringMapArgs{}
}

func (p *TestServiceEchoBool2StringMapArgs) GetReq() (v map[bool]string) {
	return p.Req
}
func (p *TestServiceEchoBool2StringMapArgs) SetReq(val map[bool]string) {
	p.Req = val
}

func (p *TestServiceEchoBool2StringMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2StringMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2StringMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2StringMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2StringMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2StringMapResult struct {
	Success map[bool]string `thrift:"success,0,optional" frugal:"0,optional,map<bool:string>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2StringMapResult() *TestServiceEchoBool2StringMapResult {
	return &TestServiceEchoBool2StringMapResult{}
}

func (p *TestServiceEchoBool2StringMapResult) InitDefault() {
	*p = TestServiceEchoBool2StringMapResult{}
}

var TestServiceEchoBool2StringMapResult_Success_DEFAULT map[bool]string

func (p *TestServiceEchoBool2StringMapResult) GetSuccess() (v map[bool]string) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2StringMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2StringMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool]string)
}

func (p *TestServiceEchoBool2StringMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2StringMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2StringMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2StringMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2StringMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2StringMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BinaryMapArgs struct {
	Req map[bool][]byte `thrift:"req,1" frugal:"1,default,map<bool:binary>" json:"req"`
}

func NewTestServiceEchoBool2BinaryMapArgs() *TestServiceEchoBool2BinaryMapArgs {
	return &TestServiceEchoBool2BinaryMapArgs{}
}

func (p *TestServiceEchoBool2BinaryMapArgs) InitDefault() {
	*p = TestServiceEchoBool2BinaryMapArgs{}
}

func (p *TestServiceEchoBool2BinaryMapArgs) GetReq() (v map[bool][]byte) {
	return p.Req
}
func (p *TestServiceEchoBool2BinaryMapArgs) SetReq(val map[bool][]byte) {
	p.Req = val
}

func (p *TestServiceEchoBool2BinaryMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BinaryMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2BinaryMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2BinaryMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BinaryMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BinaryMapResult struct {
	Success map[bool][]byte `thrift:"success,0,optional" frugal:"0,optional,map<bool:binary>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2BinaryMapResult() *TestServiceEchoBool2BinaryMapResult {
	return &TestServiceEchoBool2BinaryMapResult{}
}

func (p *TestServiceEchoBool2BinaryMapResult) InitDefault() {
	*p = TestServiceEchoBool2BinaryMapResult{}
}

var TestServiceEchoBool2BinaryMapResult_Success_DEFAULT map[bool][]byte

func (p *TestServiceEchoBool2BinaryMapResult) GetSuccess() (v map[bool][]byte) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2BinaryMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2BinaryMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]byte)
}

func (p *TestServiceEchoBool2BinaryMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2BinaryMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BinaryMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2BinaryMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2BinaryMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BinaryMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BoolListMapArgs struct {
	Req map[bool][]bool `thrift:"req,1" frugal:"1,default,map<bool:list<bool>>" json:"req"`
}

func NewTestServiceEchoBool2BoolListMapArgs() *TestServiceEchoBool2BoolListMapArgs {
	return &TestServiceEchoBool2BoolListMapArgs{}
}

func (p *TestServiceEchoBool2BoolListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2BoolListMapArgs{}
}

func (p *TestServiceEchoBool2BoolListMapArgs) GetReq() (v map[bool][]bool) {
	return p.Req
}
func (p *TestServiceEchoBool2BoolListMapArgs) SetReq(val map[bool][]bool) {
	p.Req = val
}

func (p *TestServiceEchoBool2BoolListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BoolListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2BoolListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2BoolListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BoolListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BoolListMapResult struct {
	Success map[bool][]bool `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<bool>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2BoolListMapResult() *TestServiceEchoBool2BoolListMapResult {
	return &TestServiceEchoBool2BoolListMapResult{}
}

func (p *TestServiceEchoBool2BoolListMapResult) InitDefault() {
	*p = TestServiceEchoBool2BoolListMapResult{}
}

var TestServiceEchoBool2BoolListMapResult_Success_DEFAULT map[bool][]bool

func (p *TestServiceEchoBool2BoolListMapResult) GetSuccess() (v map[bool][]bool) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2BoolListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2BoolListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]bool)
}

func (p *TestServiceEchoBool2BoolListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2BoolListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BoolListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2BoolListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2BoolListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BoolListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2ByteListMapArgs struct {
	Req map[bool][]int8 `thrift:"req,1" frugal:"1,default,map<bool:list<byte>>" json:"req"`
}

func NewTestServiceEchoBool2ByteListMapArgs() *TestServiceEchoBool2ByteListMapArgs {
	return &TestServiceEchoBool2ByteListMapArgs{}
}

func (p *TestServiceEchoBool2ByteListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2ByteListMapArgs{}
}

func (p *TestServiceEchoBool2ByteListMapArgs) GetReq() (v map[bool][]int8) {
	return p.Req
}
func (p *TestServiceEchoBool2ByteListMapArgs) SetReq(val map[bool][]int8) {
	p.Req = val
}

func (p *TestServiceEchoBool2ByteListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2ByteListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2ByteListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2ByteListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2ByteListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2ByteListMapResult struct {
	Success map[bool][]int8 `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<byte>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2ByteListMapResult() *TestServiceEchoBool2ByteListMapResult {
	return &TestServiceEchoBool2ByteListMapResult{}
}

func (p *TestServiceEchoBool2ByteListMapResult) InitDefault() {
	*p = TestServiceEchoBool2ByteListMapResult{}
}

var TestServiceEchoBool2ByteListMapResult_Success_DEFAULT map[bool][]int8

func (p *TestServiceEchoBool2ByteListMapResult) GetSuccess() (v map[bool][]int8) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2ByteListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2ByteListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]int8)
}

func (p *TestServiceEchoBool2ByteListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2ByteListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2ByteListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2ByteListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2ByteListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2ByteListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int16ListMapArgs struct {
	Req map[bool][]int16 `thrift:"req,1" frugal:"1,default,map<bool:list<i16>>" json:"req"`
}

func NewTestServiceEchoBool2Int16ListMapArgs() *TestServiceEchoBool2Int16ListMapArgs {
	return &TestServiceEchoBool2Int16ListMapArgs{}
}

func (p *TestServiceEchoBool2Int16ListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2Int16ListMapArgs{}
}

func (p *TestServiceEchoBool2Int16ListMapArgs) GetReq() (v map[bool][]int16) {
	return p.Req
}
func (p *TestServiceEchoBool2Int16ListMapArgs) SetReq(val map[bool][]int16) {
	p.Req = val
}

func (p *TestServiceEchoBool2Int16ListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int16ListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2Int16ListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2Int16ListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int16ListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int16ListMapResult struct {
	Success map[bool][]int16 `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<i16>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2Int16ListMapResult() *TestServiceEchoBool2Int16ListMapResult {
	return &TestServiceEchoBool2Int16ListMapResult{}
}

func (p *TestServiceEchoBool2Int16ListMapResult) InitDefault() {
	*p = TestServiceEchoBool2Int16ListMapResult{}
}

var TestServiceEchoBool2Int16ListMapResult_Success_DEFAULT map[bool][]int16

func (p *TestServiceEchoBool2Int16ListMapResult) GetSuccess() (v map[bool][]int16) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2Int16ListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2Int16ListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]int16)
}

func (p *TestServiceEchoBool2Int16ListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2Int16ListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int16ListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2Int16ListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2Int16ListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int16ListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int32ListMapArgs struct {
	Req map[bool][]int32 `thrift:"req,1" frugal:"1,default,map<bool:list<i32>>" json:"req"`
}

func NewTestServiceEchoBool2Int32ListMapArgs() *TestServiceEchoBool2Int32ListMapArgs {
	return &TestServiceEchoBool2Int32ListMapArgs{}
}

func (p *TestServiceEchoBool2Int32ListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2Int32ListMapArgs{}
}

func (p *TestServiceEchoBool2Int32ListMapArgs) GetReq() (v map[bool][]int32) {
	return p.Req
}
func (p *TestServiceEchoBool2Int32ListMapArgs) SetReq(val map[bool][]int32) {
	p.Req = val
}

func (p *TestServiceEchoBool2Int32ListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int32ListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2Int32ListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2Int32ListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int32ListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int32ListMapResult struct {
	Success map[bool][]int32 `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<i32>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2Int32ListMapResult() *TestServiceEchoBool2Int32ListMapResult {
	return &TestServiceEchoBool2Int32ListMapResult{}
}

func (p *TestServiceEchoBool2Int32ListMapResult) InitDefault() {
	*p = TestServiceEchoBool2Int32ListMapResult{}
}

var TestServiceEchoBool2Int32ListMapResult_Success_DEFAULT map[bool][]int32

func (p *TestServiceEchoBool2Int32ListMapResult) GetSuccess() (v map[bool][]int32) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2Int32ListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2Int32ListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]int32)
}

func (p *TestServiceEchoBool2Int32ListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2Int32ListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int32ListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2Int32ListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2Int32ListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int32ListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int64ListMapArgs struct {
	Req map[bool][]int64 `thrift:"req,1" frugal:"1,default,map<bool:list<i64>>" json:"req"`
}

func NewTestServiceEchoBool2Int64ListMapArgs() *TestServiceEchoBool2Int64ListMapArgs {
	return &TestServiceEchoBool2Int64ListMapArgs{}
}

func (p *TestServiceEchoBool2Int64ListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2Int64ListMapArgs{}
}

func (p *TestServiceEchoBool2Int64ListMapArgs) GetReq() (v map[bool][]int64) {
	return p.Req
}
func (p *TestServiceEchoBool2Int64ListMapArgs) SetReq(val map[bool][]int64) {
	p.Req = val
}

func (p *TestServiceEchoBool2Int64ListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int64ListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2Int64ListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2Int64ListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int64ListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2Int64ListMapResult struct {
	Success map[bool][]int64 `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<i64>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2Int64ListMapResult() *TestServiceEchoBool2Int64ListMapResult {
	return &TestServiceEchoBool2Int64ListMapResult{}
}

func (p *TestServiceEchoBool2Int64ListMapResult) InitDefault() {
	*p = TestServiceEchoBool2Int64ListMapResult{}
}

var TestServiceEchoBool2Int64ListMapResult_Success_DEFAULT map[bool][]int64

func (p *TestServiceEchoBool2Int64ListMapResult) GetSuccess() (v map[bool][]int64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2Int64ListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2Int64ListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]int64)
}

func (p *TestServiceEchoBool2Int64ListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2Int64ListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2Int64ListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2Int64ListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2Int64ListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2Int64ListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2DoubleListMapArgs struct {
	Req map[bool][]float64 `thrift:"req,1" frugal:"1,default,map<bool:list<double>>" json:"req"`
}

func NewTestServiceEchoBool2DoubleListMapArgs() *TestServiceEchoBool2DoubleListMapArgs {
	return &TestServiceEchoBool2DoubleListMapArgs{}
}

func (p *TestServiceEchoBool2DoubleListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2DoubleListMapArgs{}
}

func (p *TestServiceEchoBool2DoubleListMapArgs) GetReq() (v map[bool][]float64) {
	return p.Req
}
func (p *TestServiceEchoBool2DoubleListMapArgs) SetReq(val map[bool][]float64) {
	p.Req = val
}

func (p *TestServiceEchoBool2DoubleListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2DoubleListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2DoubleListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2DoubleListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2DoubleListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2DoubleListMapResult struct {
	Success map[bool][]float64 `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<double>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2DoubleListMapResult() *TestServiceEchoBool2DoubleListMapResult {
	return &TestServiceEchoBool2DoubleListMapResult{}
}

func (p *TestServiceEchoBool2DoubleListMapResult) InitDefault() {
	*p = TestServiceEchoBool2DoubleListMapResult{}
}

var TestServiceEchoBool2DoubleListMapResult_Success_DEFAULT map[bool][]float64

func (p *TestServiceEchoBool2DoubleListMapResult) GetSuccess() (v map[bool][]float64) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2DoubleListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2DoubleListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]float64)
}

func (p *TestServiceEchoBool2DoubleListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2DoubleListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2DoubleListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2DoubleListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2DoubleListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2DoubleListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2StringListMapArgs struct {
	Req map[bool][]string `thrift:"req,1" frugal:"1,default,map<bool:list<string>>" json:"req"`
}

func NewTestServiceEchoBool2StringListMapArgs() *TestServiceEchoBool2StringListMapArgs {
	return &TestServiceEchoBool2StringListMapArgs{}
}

func (p *TestServiceEchoBool2StringListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2StringListMapArgs{}
}

func (p *TestServiceEchoBool2StringListMapArgs) GetReq() (v map[bool][]string) {
	return p.Req
}
func (p *TestServiceEchoBool2StringListMapArgs) SetReq(val map[bool][]string) {
	p.Req = val
}

func (p *TestServiceEchoBool2StringListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2StringListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2StringListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2StringListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2StringListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2StringListMapResult struct {
	Success map[bool][]string `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<string>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2StringListMapResult() *TestServiceEchoBool2StringListMapResult {
	return &TestServiceEchoBool2StringListMapResult{}
}

func (p *TestServiceEchoBool2StringListMapResult) InitDefault() {
	*p = TestServiceEchoBool2StringListMapResult{}
}

var TestServiceEchoBool2StringListMapResult_Success_DEFAULT map[bool][]string

func (p *TestServiceEchoBool2StringListMapResult) GetSuccess() (v map[bool][]string) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2StringListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2StringListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][]string)
}

func (p *TestServiceEchoBool2StringListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2StringListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2StringListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2StringListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2StringListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2StringListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BinaryListMapArgs struct {
	Req map[bool][][]byte `thrift:"req,1" frugal:"1,default,map<bool:list<binary>>" json:"req"`
}

func NewTestServiceEchoBool2BinaryListMapArgs() *TestServiceEchoBool2BinaryListMapArgs {
	return &TestServiceEchoBool2BinaryListMapArgs{}
}

func (p *TestServiceEchoBool2BinaryListMapArgs) InitDefault() {
	*p = TestServiceEchoBool2BinaryListMapArgs{}
}

func (p *TestServiceEchoBool2BinaryListMapArgs) GetReq() (v map[bool][][]byte) {
	return p.Req
}
func (p *TestServiceEchoBool2BinaryListMapArgs) SetReq(val map[bool][][]byte) {
	p.Req = val
}

func (p *TestServiceEchoBool2BinaryListMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BinaryListMapArgs(%+v)", *p)
}
func (p *TestServiceEchoBool2BinaryListMapArgs) GetFirstArgument() interface{} {
	return p.Req
}
func (p *TestServiceEchoBool2BinaryListMapArgs) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Req)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BinaryListMapArgs) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}

type TestServiceEchoBool2BinaryListMapResult struct {
	Success map[bool][][]byte `thrift:"success,0,optional" frugal:"0,optional,map<bool:list<binary>>" json:"success,omitempty"`
}

func NewTestServiceEchoBool2BinaryListMapResult() *TestServiceEchoBool2BinaryListMapResult {
	return &TestServiceEchoBool2BinaryListMapResult{}
}

func (p *TestServiceEchoBool2BinaryListMapResult) InitDefault() {
	*p = TestServiceEchoBool2BinaryListMapResult{}
}

var TestServiceEchoBool2BinaryListMapResult_Success_DEFAULT map[bool][][]byte

func (p *TestServiceEchoBool2BinaryListMapResult) GetSuccess() (v map[bool][][]byte) {
	if !p.IsSetSuccess() {
		return TestServiceEchoBool2BinaryListMapResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestServiceEchoBool2BinaryListMapResult) SetSuccess(x interface{}) {
	p.Success = x.(map[bool][][]byte)
}

func (p *TestServiceEchoBool2BinaryListMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestServiceEchoBool2BinaryListMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestServiceEchoBool2BinaryListMapResult(%+v)", *p)
}
func (p *TestServiceEchoBool2BinaryListMapResult) GetResult() interface{} {
	return p.Success
}
func (p *TestServiceEchoBool2BinaryListMapResult) Encode(e codec.Encoder) error {
	var err error
	err = e.Encode(p.Success)
	if err != nil {
		return err
	}

	return nil
}

func (p *TestServiceEchoBool2BinaryListMapResult) Decode(d codec.Decoder) error {
	var (
		err error
		v   interface{}
	)
	v, err = d.Decode()
	if err != nil {
		return err
	}
	err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}

	return nil
}
