// Copyright 2024 CloudWeGo Authors
//
// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package templates

import "github.com/kitex-contrib/codec-dubbo/tools/protoc-gen-kitex-dubbo/generator"

func init() {
	generator.RegisterTemplate(StructLikes,
		Header,
		StructLike,
		Service,
		JavaClassName,
	)
}

var Header = `
{{- define "header"}}
// Code generated by protoc-gen-kitex-dubbbo {{.Version}}. DO NOT EDIT.

{{- end }}
`

const Service = `
{{- define "service"}}
{{template "header" .}}

package {{ .PkgName}}

import (
    "fmt"

	"github.com/pkg/errors"

	"github.com/kitex-contrib/codec-dubbo/pkg/hessian2"
	codec "github.com/kitex-contrib/codec-dubbo/pkg/iface"
)

{{- range .Functions}}
func (p *{{.Method}}Args) Encode(e codec.Encoder) error {
    var err error
	err = e.Encode(p.Req)
    if err != nil {
    	return err
	}
	return nil
}

func (p *{{.Method}}Args) Decode(d codec.Decoder) error {
	var (
		err error
		v interface{}
	)
	v, err = d.Decode()
    if err != nil {
    	return err
	}
    err = hessian2.ReflectResponse(v, &p.Req)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}
	return nil
} 

func (p *{{.Method}}Result) Encode(e codec.Encoder) error {
    var err error
	err = e.Encode(p.Success)
    if err != nil {
    	return err
	}
	return nil
}

func (p *{{.Method}}Result) Decode(d codec.Decoder) error {
	var (
		err error
		v interface{}
	)
	v, err = d.Decode()
    if err != nil {
    	return err
	}
    err = hessian2.ReflectResponse(v, &p.Success)
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}
	return nil
} 
{{- end}} {{/* range .Functions */}}

{{- end}}{{/* define FunctionHessian*/}}
`

const StructLikes = `
{{- define "structlikes"}}
{{template "header" .}}

package {{ .PkgName}}

import (
    "fmt"

	"github.com/pkg/errors"

	"github.com/kitex-contrib/codec-dubbo/pkg/hessian2"
	codec "github.com/kitex-contrib/codec-dubbo/pkg/iface"
)

var objects{{.IDLName}} = []interface{}{ 
{{- range .StructLikes}}
    &{{.Name}}{},
{{- end}} 
}

func init() {
	hessian2.Register(objects{{.IDLName}} )
}

{{range .Services }}
func Get{{.Name}}IDLAnnotations() map[string][]string {
	return map[string][]string {
        {{- range .Annotations}}
		"{{.Key}}": { {{range .Values}}"{{.}}", {{- end}}},
        {{- end}}
	}
}
{{- end}}

{{- range .StructLikes}}
{{template "structlike" . }}
{{- end}}

{{- end}}{{/* define RegisterHessian*/}}
`

const StructLike = `
{{define "structlike"}}
{{- $TypeName := .Name}}
func (p *{{$TypeName}}) Encode(e codec.Encoder) error {
{{- if gt (len .Fields) 0}}
    var err error
{{- end}}
{{- range .Fields}}
{{- $FieldName := .Name}}
	err = e.Encode(p.{{$FieldName}})
    if err != nil {
    	return err
	}
{{end}}{{/* range .Fields */}}
	return nil
}

func (p *{{$TypeName}}) Decode(d codec.Decoder) error {
{{- if gt (len .Fields) 0}}
	var (
		err error
		v interface{}
	)
{{- end}}
{{- range .Fields}}
{{- $FieldName := .Name}}
	v, err = d.Decode()
    if err != nil {
    	return err
	}
    err = hessian2.ReflectResponse(v, &p.{{$FieldName}})
	if err != nil {
		return errors.Wrap(err, fmt.Sprintf("invalid data type: %T", v))
	}
{{end}}{{/* range .Fields */}}
	return nil
} {{/* encode decode */}}

{{template "javaclassname" .}}
{{- end}}{{/* define "StructLikeProtocol" */}}
`

const JavaClassName = `
{{define "javaclassname"}}
{{- $TypeName := .Name}}
func (p *{{$TypeName}}) JavaClassName() string {
	return "{{.JavaPackage}}.{{$TypeName}}"
}
{{- end}}{{/* define "JavaClassName" */}}
`
